import { PrismaClient } from "@prisma/client";
import * as grpc from "@grpc/grpc-js";
import { Vulnerability as VulnerabilityType } from "../generated/Vulnerability";
import { VulnerabilityId as VulnerabilityIdType } from "../generated/VulnerabilityId";
import { Empty as EmptyType } from "../generated/Empty";
import { Pentester as PentesterType } from "../generated/Pentester";

const prisma = new PrismaClient();

export async function addVulnerability(
  call: grpc.ServerUnaryCall<VulnerabilityType, VulnerabilityType>,
  callback: grpc.sendUnaryData<VulnerabilityType>,
) {
  try {
    const newVulnerability = await prisma.vulnerability.create({
      data: {
        type: call.request.type || "",
        company: call.request.company || "",
        pentester: call.request.pentester || "",
      },
    });
    callback(null, {
      id: newVulnerability.id.toString(),
      type: newVulnerability.type,
      company: newVulnerability.company,
      pentester: newVulnerability.pentester,
    });
  } catch (error) {
    callback({
      code: grpc.status.INTERNAL,
      message: "Internal server error",
    });
  }
}

export async function getVulnerability(
  call: grpc.ServerUnaryCall<VulnerabilityIdType, VulnerabilityType>,
  callback: grpc.sendUnaryData<VulnerabilityType>,
) {
  try {
    if (!call.request.id) {
      callback({
        code: grpc.status.INVALID_ARGUMENT,
        message: "ID is required",
      });
      return;
    }

    const vulnerability = await prisma.vulnerability.findUnique({
      where: { id: parseInt(call.request.id, 10) },
    });
    if (vulnerability) {
      callback(null, {
        id: vulnerability.id.toString(),
        type: vulnerability.type,
        company: vulnerability.company,
        pentester: vulnerability.pentester,
      });
    } else {
      callback({
        code: grpc.status.NOT_FOUND,
        message: "Vulnerability not found",
      });
    }
  } catch (error) {
    callback({
      code: grpc.status.INTERNAL,
      message: "Internal server error",
    });
  }
}

export async function listVulnerabilities(
  call: grpc.ServerWritableStream<EmptyType, VulnerabilityType>,
) {
  try {
    const allVulnerabilities = await prisma.vulnerability.findMany();
    allVulnerabilities.forEach((vulnerability) =>
      call.write({
        id: vulnerability.id.toString(),
        type: vulnerability.type,
        company: vulnerability.company,
        pentester: vulnerability.pentester,
      }),
    );
    call.end();
  } catch (error) {
    call.destroy(error as Error);
  }
}

export async function updateVulnerability(
  call: grpc.ServerUnaryCall<VulnerabilityType, VulnerabilityType>,
  callback: grpc.sendUnaryData<VulnerabilityType>,
) {
  try {
    if (!call.request.id) {
      callback({
        code: grpc.status.INVALID_ARGUMENT,
        message: "ID is required",
      });
      return;
    }

    const updatedVulnerability = await prisma.vulnerability.update({
      where: { id: parseInt(call.request.id, 10) },
      data: {
        type: call.request.type || "",
        company: call.request.company || "",
        pentester: call.request.pentester || "",
      },
    });
    callback(null, {
      id: updatedVulnerability.id.toString(),
      type: updatedVulnerability.type,
      company: updatedVulnerability.company,
      pentester: updatedVulnerability.pentester,
    });
  } catch (error) {
    callback({
      code: grpc.status.NOT_FOUND,
      message: "Vulnerability not found",
    });
  }
}

export async function deleteVulnerability(
  call: grpc.ServerUnaryCall<VulnerabilityIdType, EmptyType>,
  callback: grpc.sendUnaryData<EmptyType>,
) {
  try {
    if (!call.request.id) {
      callback({
        code: grpc.status.INVALID_ARGUMENT,
        message: "ID is required",
      });
      return;
    }

    await prisma.vulnerability.delete({
      where: { id: parseInt(call.request.id, 10) },
    });
    callback(null, {});
  } catch (error) {
    callback({
      code: grpc.status.NOT_FOUND,
      message: "Vulnerability not found",
    });
  }
}

export async function listPentesters(
  call: grpc.ServerWritableStream<EmptyType, PentesterType>,
) {
  try {
    const allPentesters = await prisma.pentester.findMany();
    allPentesters.forEach((pentester) =>
      call.write({
        id: pentester.id.toString(),
        name: pentester.name,
      }),
    );
    call.end();
  } catch (error) {
    call.destroy(error as Error);
  }
}
